[rCore tutorial 实验入门指导](https://blog.ideawand.com/2022/11/18/rcore_tutorial/os-camp-2022-winter-riscv/)

[riscvbook](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)

# 特权级架构
> 管理、保护共享资源，对上层用户屏蔽下层实现细节

> 下层为上层提供调用接口。上层不必关心下层的具体实现。


+ User (U Mode) 最低特权级 平时可以称作 用户态
+ Supervisor (S Mode) 中等特权级 平时可以称作监管者模式、内核态、特权态等。
+ Machine （M-Mode） 最高特权级 通常称作机器态


+ M，最简单的单片机嵌入式系统，它自己可以在没有复杂外界输入的情况下自己运行。没有什么外部网络接入（即程序烧写之后也几乎不会更新，你可以认为在上面跑的代码是绝对安全的）。这个时候不需要区分特权态和用户态，代码就在最高权限跑就行，应用层的代码就对整个CPU享有完全的控制权，成本最低。
    + 这样的CPU上面也可以跑嵌入式操作系统实现分时多任务调度（例如FreeRTOS之类的），但是各个任务之间，没有内存访问保护的，任意一段应用程序代码，只要知道操作系统内核数据结构的内存地址，就可以轻松去修改操作系统内核的数据。这个时候的嵌入式操作系统，只有任务调度的功能，并没有保障安全的能力，操作系统自己可以随时被一个应用程序搞垮。
+ M+U，相比于第一种，增加了内存保护功能。例如对于IOT设备，他们是接入网络的，并且可以通过网络获取外部的指令，甚至自己进行OTA程序升级。这样的设备就有可能受到不安全代码的攻击（你的程序可能被动态替换掉，你没法保证新进来的程序是安全的，另外对于一些非法的输入数据也可能对你的设备进行攻击）。
    + 在这类CPU上，就可以让操作系统运行在M态，用户程序运行在U态，把操作系统所在的程序段、以及使用到的内存段，通过内存保护机制限制U态用户程序的访问。这种处理器上的操作系统，既可以实现任务的调度，也可以保证在用户程序干坏事的时候内核自己不受影响。
+ M+S+U，相比于前两种，这一种引入了S态，而S态很重要的一个作用就是引入了页表，从而可以实现虚拟内存相关的一系列高端功能。也就是说支持这三个特权态的处理器都是配备有MMU的，因此也就可以跑类Unix操作系统了。


每一个更高级别的特权模式的功能都会比低级的更强大，这种强大体现在两方面：

+ 更高的特权级可以执行更多的指令，而低特权级不能执行这些指令
+ 更高的特权级可以操作更多的CSR（Control/Status Register）

每个特权级只能操作自己以及比自己特权级低的特权级所拥有的CSR。

![20221120234252](https://cdn.jsdelivr.net/gh/lnyo-cly/blogImg/pics/20221120234252.png)

## 特权态指令以及各个特权态的CSR

各个特权级可以做的事情，用集合概念来表示，是一个包含结构，用户态是最小子集，内核态比用户态大一些，机器态则比内核态再大一些。

![20221120234651](https://cdn.jsdelivr.net/gh/lnyo-cly/blogImg/pics/20221120234651.png)

+ 各个特权级都拥有的指令（也就是最小子集）：
    + ECALL 主要用于特权态切换，通常的用法是在U态调用ECALL来陷入S态，在S态调用ECALL来陷入M态。（不过为了实现这种陷入关系，需要有额外的配置，下文会说明）
    + EBREAK 产生断点异常，对于程序调试有帮助
    + FENCE.I 产生一个内存读写屏障
    + SRET 从S态返回U态（只有在支持S态的CPU上才可以）
        + URET我们用不到，自行了解
+ S 态引入的指令：
    + SFENCE.VMA 主要的作用是刷页表
+ M 态引入的指令：
    + WFI： 让当前处理器核心进入睡眠状态


+ CSR寄存器有自己的一套独立的地址空间，并且访问CSR需要使用专用的指令。
+ 每一个处理器核心都有自己一套独立的4K CSR, 这4K CSR分别对应到4个特权态（U\S\M是我们之前提到的三个，第四个和虚拟化有关，我们不讨论）所以对于每一个特权态，最多有1024个CSR可以使用。
+ 访问没有权限的CSR会Trap，访问不存在的CSR会Trap，写只读的CSR会Trap，对于可选寄存器的操作会被忽略


# 虚拟内存

+ 最小的页大小是4kB
+ 有多种地址映射的方式（Sv32、Sv39、Sv48等）， 我们实验要用到的是Sv39，也就是说我们的虚拟地址空间由39bit的地址组成，可以寻址512GB的地址空间。
+ 巨页、ASID相关的知识不再我们讨论范围之内



# 内存保护


+ 如果处理器支持并开启的内存地址转换（也就是用了页表），那么可以通过页表项里面的权限位来控制每个内存页的访问权限。（我们的实验中会涉及到相关的操作）
+ 如果处理器不支持S特权态（比较简单廉价的处理器），他可能支持物理内存保护单元（PMP），RISC-V的内存保护单元最多支持保护16片内存区域，也就是说你可以为最多16片内存区域设置各自不同的访问权限。（但是很多嵌入式处理器可能只支持4个或8个保护区）
+ 如果同时启用了虚拟内存和物理内存保护单元，那么虚拟内存权限控制优先于PMP




# 中断与异常

+ 异常：同步事件，发生的原因是明确的（由具体的某一条指令而导致的）
+ 中断：异步事件，并不是因为某一条指令的执行而造成的，是外部事件造成的
+ 中断和异常的处理流程“几乎”是一样的















